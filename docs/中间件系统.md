# 中间件系统

Letter Box 的中间件系统提供了一套类似 Go/Java 的中间件模式，用于组合和复用 API 路由逻辑。

## 核心概念

### 什么是中间件？

中间件是一个函数，接收一个路由处理器并返回一个新的路由处理器，允许在请求处理前后执行通用逻辑（如认证、日志、错误处理等）。

### 洋葱模型

中间件采用"洋葱模型"执行：

```
请求 → [withErrorHandling → [withAuth → [业务逻辑] ← withAuth] ← withErrorHandling] ← 响应
```

外层中间件可以捕获内层中间件的错误，实现统一的错误处理。

## 快速开始

## 统一响应

项目 API 建议统一使用 `apiOk()` / `apiError()` 返回固定结构，避免在顶层随意添加字段：

```json
// 成功
{ "success": true, "data": {}, "error": null, "message": null }

// 失败
{ "success": false, "data": null, "error": "UNAUTHORIZED", "message": "未授权访问" }
```

### 基本使用

```typescript
import { compose, withErrorHandling, withAuth } from '@/lib/middleware';
import { apiOk } from '@/lib/api/response';

export const GET = compose(
  withErrorHandling(),
  withAuth(),
  async (request) => {
    // 业务逻辑
    const session = request.context.session;
    return apiOk({ userId: session.userId });
  }
);
```

### 请求上下文

中间件通过 `request.context` 传递数据：

```typescript
interface RequestContext {
  session?: SessionData;  // 由 withAuth() 注入
  ip?: string;            // 由 withRateLimit() 注入
  startTime?: number;     // 由 withLogging() 注入
}
```

## 可用中间件

### `withErrorHandling()`

**功能**: 统一错误处理，捕获所有错误并返回标准化的错误响应

**位置**: 应放在最外层（第一个）

**示例**:
```typescript
export const POST = compose(
  withErrorHandling(),
  // ... 其他中间件
  async (request) => {
    // 抛出错误会被自动捕获并格式化
    throw new Error('UNAUTHORIZED'); // → 401 响应
  }
);
```

**支持的错误类型**:
- `UNAUTHORIZED` → 401
- `FORBIDDEN` → 403
- `NOT_FOUND` → 404
- `BAD_REQUEST` → 400
- 其他 → 500 (INTERNAL_ERROR)

---

### `withAuth()`

**功能**: 验证用户已登录，并将 session 注入到 `request.context`

**依赖**: 需要配合 `withErrorHandling()` 使用

**示例**:
```typescript
export const GET = compose(
  withErrorHandling(),
  withAuth(),
  async (request) => {
    const { userId, role } = request.context.session!;
    // 已确保用户已登录
  }
);
```

---

### `withRoleCheck(role)`

**功能**: 检查用户是否具有特定角色

**参数**:
- `role: UserRole` - 必需的角色（'admin' | 'viewer'）

**依赖**: **必须**在 `withAuth()` 之后使用

**示例**:
```typescript
export const DELETE = compose(
  withErrorHandling(),
  withAuth(),
  withRoleCheck('admin'),
  async (request) => {
    // 只有 admin 可以访问
  }
);
```

---

### `withRateLimit()`

**功能**: 检查客户端 IP 是否被限流（登录失败次数过多）

**注入**: `request.context.ip` - 客户端 IP 地址

**示例**:
```typescript
export const POST = compose(
  withErrorHandling(),
  withRateLimit(),
  async (request) => {
    const ip = request.context.ip!;
    // 自动检查 IP 限流，超限会返回 429
  }
);
```

---

### `withLogging(options?)`

**功能**: 记录请求的方法、路径、耗时等信息

**参数**:
```typescript
{
  verbose?: boolean; // 是否记录详细信息
}
```

**示例**:
```typescript
export const POST = compose(
  withLogging({ verbose: true }),
  withErrorHandling(),
  async (request) => {
    // 请求会被自动记录
  }
);
```

**输出示例**:
```
[2025-12-30T10:30:15.123Z] POST /api/auth/login - 200 (125ms)
```

## 中间件顺序

**推荐顺序**（从外到内）：

1. `withLogging()` - 记录所有请求
2. `withErrorHandling()` - 捕获所有错误
3. `withRateLimit()` - IP 限流检查
4. `withAuth()` - 身份认证
5. `withRoleCheck()` - 角色权限检查
6. 业务逻辑

**示例**:
```typescript
export const PUT = compose(
  withLogging(),
  withErrorHandling(),
  withAuth(),
  withRoleCheck('admin'),
  async (request) => {
    // 业务逻辑
  }
);
```

## 实战示例

（以下示例省略了 `import`，默认已引入 `apiOk` / `apiError`。）

### 示例 1: 公开 API（无需认证）

```typescript
export const GET = compose(
  withErrorHandling(),
  async (request) => {
    return apiOk({ message: 'Hello, World!' });
  }
);
```

### 示例 2: 需要登录的 API

```typescript
export const GET = compose(
  withErrorHandling(),
  withAuth(),
  async (request) => {
    const session = request.context.session!;
    return apiOk({
      userId: session.userId,
      role: session.role,
    });
  }
);
```

### 示例 3: 仅管理员可访问的 API

```typescript
export const DELETE = compose(
  withErrorHandling(),
  withAuth(),
  withRoleCheck('admin'),
  async (request) => {
    const { id } = await request.json();
    // 删除资源
    return apiOk(null);
  }
);
```

### 示例 4: 带限流保护的登录 API

```typescript
export const POST = compose(
  withErrorHandling(),
  withRateLimit(),
  async (request) => {
    const ip = request.context.ip!;
    const { password } = await request.json();

    // 验证密码逻辑
    // ...

    return apiOk(null);
  }
);
```

### 示例 5: 完整功能的 API

```typescript
export const POST = compose(
  withLogging({ verbose: true }),
  withErrorHandling(),
  withAuth(),
  withRoleCheck('admin'),
  async (request) => {
    const session = request.context.session!;
    const data = await request.json();

    // 验证数据
    if (!data.title) {
      throw new Error('BAD_REQUEST');
    }

    // 业务逻辑
    const result = await createResource(data);

    return apiOk(result);
  }
);
```

## 类型安全

所有中间件都是完全类型安全的：

```typescript
import type { RequestWithContext } from '@/lib/middleware';

export const GET = compose(
  withErrorHandling(),
  withAuth(),
  async (request: RequestWithContext) => {
    // TypeScript 会自动提示 request.context 的可用字段
    const session = request.context.session; // ✓ 类型安全
    const ip = request.context.ip;           // ✓ 类型安全
  }
);
```

## 自定义中间件

你可以轻松创建自定义中间件：

```typescript
import type { Middleware, RouteHandler } from '@/lib/middleware';
import { withContext } from '@/lib/middleware';

export function withCustomMiddleware(): Middleware {
  return (handler: RouteHandler): RouteHandler => {
    return async (request) => {
      const reqWithContext = withContext(request);

      // 前置逻辑
      console.log('Before handler');

      // 可以注入自定义数据到上下文
      reqWithContext.context.customData = 'some value';

      // 调用下一个处理器
      const response = await handler(reqWithContext);

      // 后置逻辑
      console.log('After handler');

      return response;
    };
  };
}
```

使用自定义中间件：

```typescript
export const GET = compose(
  withErrorHandling(),
  withCustomMiddleware(),
  async (request) => {
    const data = request.context.customData; // 可以访问注入的数据
    // ...
  }
);
```

## 最佳实践

1. **始终使用 `withErrorHandling()`**
   它应该是最外层的中间件，确保所有错误都被捕获。

2. **认证中间件顺序**
   `withAuth()` 必须在 `withRoleCheck()` 之前。

3. **类型标注**
   建议显式标注 request 参数类型以获得更好的 IDE 支持：
   ```typescript
   async (request: RequestWithContext) => { ... }
   ```

4. **避免过度使用**
   只在需要时使用中间件，简单的 API 不需要所有中间件。

5. **保持中间件纯粹**
   中间件应该专注于单一职责，不要在中间件中处理业务逻辑。

## 迁移指南

### 从旧代码迁移

**旧代码**:
```typescript
import { apiOk, apiError } from '@/lib/api/response';

export async function GET() {
  try {
    const session = await getSession();
    if (!session.userId) {
      return apiError('UNAUTHORIZED', { status: 401 });
    }

    // 业务逻辑
    return apiOk('...');
  } catch (error) {
    console.error(error);
    return apiError('INTERNAL_ERROR', { status: 500 });
  }
}
```

**新代码**:
```typescript
export const GET = compose(
  withErrorHandling(),
  withAuth(),
  async (request) => {
    const session = request.context.session!;

    // 业务逻辑
    return apiOk('...');
  }
);
```

### 优势对比

| 特性 | 旧代码 | 新中间件系统 |
|------|--------|--------------|
| 代码行数 | ~15 行 | ~7 行 (-53%) |
| 错误处理 | 手动 try-catch | 自动统一处理 |
| 认证逻辑 | 每个路由重复 | 复用中间件 |
| 类型安全 | 部分 | 完全 |
| 可维护性 | 低 | 高 |
| 可测试性 | 中 | 高 |

---

**最后更新**: 2025-12-30
**维护者**: 崔昌赫
